/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./cacheservice.js":
/*!*************************!*\
  !*** ./cacheservice.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {copyObject, toDateField, arraysEquals, DateFormat, translate } = __webpack_require__(/*! ./tools */ \"./tools.js\")\n\n\nclass CacheService {\n    constructor(transportService) {\n        // to interact the server\n        this.transportService = transportService\n        // current date\n        this.today = new Date()\n        // the date containing month of the current calendar page\n        this.pageDate = this.today\n        // array of the Date() objects of the current calendar page\n        this.datesArray = []\n        // TaskObject()-s for the dates on the current calendar page\n        this.tasksArray = []\n    }\n\n    setPageDate(date) {\n        console.log('%c requesting data for changing page date: ' +\n                    `${this.pageDate}`, 'color: cornflowerblue')\n\n        return new Promise ((resolve, reject) => {\n            this.transportService.getMonthPack(date)\n                .then(pack => {\n                    this.pageDate = date\n                    this.datesArray = DatesArray.from(pack.dates)\n                    this.tasksArray = TaskArray.from(pack.tasks)\n\n                    console.log('%c requested data successfully received ' + \n                                'from the server', 'color: yellowgreen')\n                    console.log(this.tasksArray)\n                    resolve()\n                })\n                .catch(err => {\n                    console.log('%c Failed to receive data for changing ' + \n                                `page date: ${this.pageDate}`, 'color: crimson')\n                    \n                    reject(err => {\n                        throw err\n                    })\n                })\n        })\n    }\n\n    createTask(newTask) {\n        // convert Date objects to ISO string with trailing timezone values\n        for (let key in newTask) {\n            if (newTask[key] instanceof Date) {\n                newTask[key] = DateFormat.toProperISOString(newTask[key])\n            }\n        }\n\n            return this.transportService.addNewTask(newTask)\n            .then(() => {\n                console.log('%c the task successfully added to DB', 'color: yellowgreen')\n            })\n            .then(() => this.setPageDate(this.pageDate))\n            .catch(err => {\n                console.error('fail to add the task')\n                throw err\n            })\n    }\n    \n    deleteTask(deletedTask) {\n        return this.transportService.deleteTask(deletedTask.id)\n        .then(() => {\n            console.log('%c the task was successfully deleted from DB', 'color: yellowgreen')\n            let taskIndex = this.tasksArray.indexOf(deletedTask)\n            this.tasksArray.splice(taskIndex, 1)\n        })\n        .catch(err => {\n            console.error('failed to delete the task')\n            throw err\n        })\n    }\n\n    editTask(changedFields) {\n        // convert Date objects to ISO string with trailing timezone values\n        for (let key in changedFields) {\n            if (changedFields[key] instanceof Date) {\n                changedFields[key] = DateFormat.toProperISOString(changedFields[key])\n            }\n        }\n\n        return this.transportService.changeTask(changedFields)\n            .then(() => {\n                console.log('%c the task successfully changed at DB', 'color: yellowgreen')\n            })\n            .then(() => this.setPageDate(this.pageDate))\n            .catch(err => {\n                console.error('fail to edit the task')\n                throw err\n            })\n    }\n    \n    checkUncheckTask(task) {\n        // Copy the fields that represented as Date() objects,\n        // before they will be converted to ISO strings.\n        const taskDate = task.date\n        const taskCompletion = task.completion\n\n        // convert Date objects to ISO string with trailing timezone values\n        for (let key in task) {\n            if (task[key] instanceof Date) {\n                task[key] = DateFormat.toProperISOString(task[key])\n            }\n        }\n\n        return this.transportService.changeTask(task, true)\n            .then(() => {\n                console.log('%c information about the task '+\n                            'completion was changed on DB',\n                            'color: yellowgreen')\n                for(let t of this.tasksArray) {\n                    if(t.id === task.id && t.date === taskDate) {\n                        t.completion = taskCompletion\n                        break\n                    }\n                }\n            })\n            .catch(err => {\n                console.error('failed to change information about the task completion on DB')\n                throw err\n            })\n    }\n\n}\n\n\n/**Self-validating object of the user's task.\n * Accepts an object from the server, where fields are parameters of\n * a user task, checks them, throws an error if the data is not\n * consistent (there are mutually exclusive fields, etc.)\n * @param  {object} object\n */\nclass TaskObject {\n    constructor(object) {\n        this._object = copyObject(object)\n\n        // Task identifier\n        this.id = object.id\n        // Current date of the task. The task might be created on another\n        // date and repeated according to this.interval parameter.\n        // Therefore this.date and this.init_date can differ)\n        this.date = object.date\n        // Date when the task was created by user\n        this.init_date = object.init_date\n        // User-defined task name \n        this.title = object.title\n        // user-defined description of the task \n        this.description = object.description\n        // date and time when a user marked the task as completed\n        this.completion = object.completion\n        // Parameter which represents whether the task should be repeated\n        // according to certain interval of time or not\n        this.interval = object.interval\n        // a value indicating whether the task should be rescheduled to the\n        // next date if it was not completed on time (shifted if not completed)\n        this.autoshift = object.autoshift\n        // File, attached to the user-created task (text document,\n        // spreadsheet, etc.). File represented as a link to the place\n        // where the task stored.\n        this.files = object.files\n    }\n\n    set id(newValue) {\n        // TODO: need custom error\n        if (!newValue) {\n            throw 'task should have id'\n        } else if (Math.ceil(newValue) != newValue) {\n            throw 'task id should be an integer'\n        } else if (newValue < 1) {\n            throw 'task id should be >= 1'\n        } else {\n            this._object.id = newValue\n        }\n    }\n\n    get id() {\n        return this._object.id\n    }\n    \n    set date(newValue) {\n        try {\n            this._object.date = toDateField(newValue)\n        } catch(err) {\n            throw TypeError(`Invalid value of date: ${err.message}`)\n        }\n    }\n    \n    get date() {\n        return this._object.date\n    }\n\n    set init_date(newValue) {\n        try {\n            this._object.init_date = toDateField(newValue)\n        } catch(err) {\n            throw TypeError(`Invalid value of init_date: ${err.message}`)\n        }\n    }\n\n    get init_date() {\n        return this._object.init_date\n    }\n \n    set title(newValue) {\n        this._object.title = newValue\n    }\n\n    get title() {\n        return this._object.title\n    }\n\n    set description(newValue) {\n        this._object.description = newValue\n    }\n\n    get description() {\n        return this._object.description\n    }\n\n    set completion(newValue) {\n        if (newValue === false) {\n            this._object.completion = newValue\n        } else {\n            try {\n                this._object.completion = toDateField(newValue)\n            } catch(err) {\n                throw TypeError(`Invalid value of completion: ${err.message}`)\n            } \n        }\n    }\n\n    get completion() {\n        return this._object.completion\n    }\n\n    set interval(newValue) {\n        if (newValue === 'no' || newValue === false) {\n            this._object.interval = newValue\n        }\n        else if (!this._object.autoshift) {\n            this._object.interval = newValue\n        } else {\n            throw 'cannot assign interval to the task ' + \n                  'where exists autoshift value'\n        } \n    }\n\n    get interval() {\n        return this._object.interval\n    }\n\n    set autoshift(newValue) {\n        if (newValue === false) {\n            this._object.autoshift = newValue\n        } else if (this._object.interval === 'no' || !this._object.interval) {\n            this._object.autoshift = newValue\n        } else {\n            throw ('cannot assign autoshift to the ' + \n                   'task where exists interval value')\n        }\n    }\n\n    get autoshift() {\n        return this._object.autoshift\n    }\n\n    set files(newValue) {\n        // TODO: files attaching\n        this._object.files = newValue\n    }\n\n    get files() {\n        return this._object.files\n    }\n\n    get object() {\n        let objectToReturn = copyObject(this._object)\n        for (let key of Object.keys(objectToReturn)) {\n            if (objectToReturn[key] instanceof Date) {\n                objectToReturn[key] = DateFormat.toProperISOString(\n                    objectToReturn[key]\n                )\n            }\n        }\n        return objectToReturn\n    }\n\n    static getEmpty(definedValues) {\n        let emptyTaskObj = {\n            id: undefined,\n            date: undefined,\n            init_date: undefined,\n            title: '',\n            description: '',\n            completion: false,\n            interval: 'no',\n            autoshift: false,\n            files: [],\n        }\n        if (definedValues) {\n            Object.assign(emptyTaskObj, definedValues)\n        }\n        return emptyTaskObj\n    }\n}\n\n\n/**\n * Wrapper for Array to handle TaskObject-s inside it. \n */\nclass TaskArray extends Array {\n    constructor(...args) {\n        super(...args)\n        this._convertToTaskObjects(this)\n    }\n    \n    static from(arrayLike, ...args) {\n        let result = super.from(arrayLike, t => {\n            if (t instanceof TaskObject) {\n                return t\n            } else {\n                return new TaskObject(t)\n            }\n        })\n        if (args) {\n            return super.from(result, ...args)\n        } else {\n            return result\n        }\n    }\n\n    /**\n     * ->  Does this array contain tasks for the specified date?\n     * <-  'got tasks' | 'tasks done' |' no tasks' \n     * @param  {Date} date\n     */\n    checkDailyTasks(date) {\n        let haveDoneTasks = false\n        for (let task of this) {\n            if (arraysEquals(\n                [task.date.getDate(), task.date.getMonth()],\n                [date.getDate(), date.getMonth()]\n            )) {\n                if (!task.completion) {\n                    return 'got tasks'\n                } else {\n                    haveDoneTasks = true\n                }  \n            }\n        }\n        if (haveDoneTasks) {\n            return 'tasks done'\n        } else {\n            return 'no tasks'\n        }\n        \n        \n    }\n    \n    /**\n     * Get TaskObject-s where TaskObject.date equals @param date\n     * @param  {Date} date\n     */\n    getDailyTasks(date){\n        let dailyTasks = []\n        \n        for(let task of this) {\n            if (date.getDate() === task.date.getDate()\n                && date.getMonth() === task.date.getMonth()){\n                dailyTasks.push(task)\n            }\n        }\n        return dailyTasks\n    }\n\n    _convertToTaskObjects(array) {\n        for (let key of array.keys()) {\n            if (this.key instanceof TaskObject) {\n                continue\n            }\n            if (typeof this[key] === 'undefined') {\n                break\n            }\n            this[key] = new TaskObject(this[key])\n        }\n    }\n\n}\n\n\nclass DatesArray extends Array {\n    constructor(...args) {\n        super(...args)\n        this._convertStringsToDates(this)\n    }\n\n    static from(arrayLike, ...args) {\n        let result = super.from(arrayLike, d => new Date(d))\n        if (args) {\n            return super.from(result, ...args)\n        } else {\n            return result\n        }\n    }\n    \n    _convertStringsToDates(array) {\n        for (let key of array.keys()) {\n                this[key] = new Date(this[key])\n        }\n    }\n}\n\n\nmodule.exports = {\n    CacheService, TaskObject, TaskArray, DatesArray\n}\n\n\n//# sourceURL=webpack:///./cacheservice.js?");

/***/ }),

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n\n    LOCALE: __webpack_require__(/*! ./languages/ru */ \"./languages/ru.js\"),\n    \n    SERVER_URLs: {\n        base: 'http://192.168.1.15:8000/',\n        changeDate: '/getDatePack',\n        tasks: '/tasks'\n    }\n\n}\n\n//# sourceURL=webpack:///./config.js?");

/***/ }),

/***/ "./errors.js":
/*!*******************!*\
  !*** ./errors.js ***!
  \*******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { PopUpWindow } = __webpack_require__(/*! ./widgets/widget.popup */ \"./widgets/widget.popup.js\")\nconst { translate } = __webpack_require__(/*! ./tools */ \"./tools.js\")\n\nclass MissingServerError extends Error {\n    constructor(message) {\n        super(message)\n        this.name = 'MissingServerError'\n        \n        this.displayPopup()\n    }\n\n\n    displayPopup() {\n        new PopUpWindow({\n            parent: _mainContainer,\n            cssClass: 'popup-defaultError',\n            irreversible: true,\n            caption: translate('server is temporary unavailable..'),\n            svgPicture: svgPaths.oopsError\n        }).build()\n    }\n\n}\n\nmodule.exports = { MissingServerError }\n\n//# sourceURL=webpack:///./errors.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// uncomment to add styles in main.html header -->\n// import './styles/main.css'\nconst {Widget} = __webpack_require__(/*! ./widgets/widget */ \"./widgets/widget.js\")\nconst {DayButton, Calendar} = __webpack_require__(/*! ./widgets/widget.calendar */ \"./widgets/widget.calendar.js\")\nconst {IconButton24} = __webpack_require__(/*! ./widgets/widget.common */ \"./widgets/widget.common.js\")\nconst {TaskPanel} = __webpack_require__(/*! ./widgets/widget.taskpanel */ \"./widgets/widget.taskpanel.js\")\nconst { PopUpWindow } = __webpack_require__(/*! ./widgets/widget.popup */ \"./widgets/widget.popup.js\")\nconst {copyObject} = __webpack_require__(/*! ./tools */ \"./tools.js\")\nconst {CacheService, TaskObject} = __webpack_require__(/*! ./cacheservice */ \"./cacheservice.js\")\nconst {TransportService} = __webpack_require__(/*! ./transportservice */ \"./transportservice.js\")\nconst {svgPaths} = __webpack_require__(/*! ./svgpaths */ \"./svgpaths.js\")\n\n\n// Entire app launch initializations.\nconst _mainContainer = document.getElementById('_main-container')\n\nfunction launch(mainContainer) {\n    const transportService = new TransportService()\n    const cacheService = new CacheService(transportService)\n    let calendar\n    let taskPanel\n        \n    cacheService.setPageDate(cacheService.today)\n        .then( () => {\n            calendar = new Calendar(mainContainer, cacheService)\n            taskPanel = new TaskPanel(mainContainer, cacheService)\n            calendar.build()\n            taskPanel.build()  \n        })\n        .catch( err => {\n            console.error(err)\n            alert(err.errorTraceback)\n        })\n        .then(() => {\n            // Make these accessible from browser dev tools console\n            window.calendar = calendar\n            window.taskPanel = taskPanel\n        })\n}\n\nfunction giveConsoleAccess() {\n    window.Widget = Widget\n    window._mainContainer = _mainContainer\n    window.copyObject = copyObject\n    window.TaskObject = TaskObject\n    window.TransportService = TransportService\n    window.CacheService = CacheService\n    window.DayButton = DayButton\n    window.Calendar = Calendar\n    window.IconButton24 = IconButton24\n    window.svgPaths = svgPaths\n    window.TaskPanel = TaskPanel\n    window.PopUpWindow = PopUpWindow\n}\n\n\nlaunch(_mainContainer)\ngiveConsoleAccess()\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./languages/ru.js":
/*!*************************!*\
  !*** ./languages/ru.js ***!
  \*************************/
/***/ ((module) => {

eval("const ruLocale = {\n   languageTag: 'ru-Ru',\n   \n   lines: {\n      'No tasks': 'Задач нет',\n      'Postpone:': 'Отложить:',\n      'Repeat:': 'Повторять:',\n      'Auto postpone:': 'Автоперенос:',\n      'Task name:': 'Название:',\n      'Description:': 'Описание:',\n      'no interval': 'без интервала',\n      'every day': 'ежедневно',\n      'every workday': 'по будням',\n      'every week': 'еженедельно',\n      'every month': 'ежемесячно',\n      'every year': 'ежегодно',\n      'until completed': 'до выполнения',\n      'no': 'нет',\n      'server is temporary unavailable..': 'сервер временно недоступен..'\n   }\n}\n\n\nmodule.exports = ruLocale\n\n//# sourceURL=webpack:///./languages/ru.js?");

/***/ }),

/***/ "./svgpaths.js":
/*!*********************!*\
  !*** ./svgpaths.js ***!
  \*********************/
/***/ ((module) => {

eval("svgPaths = {\n    saveTask: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n               <path fill=\"none\" d=\"M9.917,0.875c-5.086,0-9.208,4.123-9.208,9.208c0,5.086,4.123,9.208,9.208,9.208s9.208-4.122,9.208-9.208\n               C19.125,4.998,15.003,0.875,9.917,0.875z M9.917,18.141c-4.451,0-8.058-3.607-8.058-8.058s3.607-8.057,8.058-8.057\n               c4.449,0,8.057,3.607,8.057,8.057S14.366,18.141,9.917,18.141z M13.851,6.794l-5.373,5.372L5.984,9.672\n               c-0.219-0.219-0.575-0.219-0.795,0c-0.219,0.22-0.219,0.575,0,0.794l2.823,2.823c0.02,0.028,0.031,0.059,0.055,0.083\n               c0.113,0.113,0.263,0.166,0.411,0.162c0.148,0.004,0.298-0.049,0.411-0.162c0.024-0.024,0.036-0.055,0.055-0.083l5.701-5.7\n               c0.219-0.219,0.219-0.575,0-0.794C14.425,6.575,14.069,6.575,13.851,6.794z\"></path>\n               </svg>`,\n    \n    pointLeft: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n                <path fill=\"none\" d=\"M8.388,10.049l4.76-4.873c0.303-0.31,0.297-0.804-0.012-1.105c-0.309-0.304-0.803-0.293-1.105,0.012L6.726,9.516c-0.303,0.31-0.296,0.805,0.012,1.105l5.433,5.307c0.152,0.148,0.35,0.223,0.547,0.223c0.203,0,0.406-0.08,0.559-0.236c0.303-0.309,0.295-0.803-0.012-1.104L8.388,10.049z\"></path>\n                </svg>`,\n    \n    pointRight: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n                 <path fill=\"none\" d=\"M11.611,10.049l-4.76-4.873c-0.303-0.31-0.297-0.804,0.012-1.105c0.309-0.304,0.803-0.293,1.105,0.012l5.306,5.433c0.304,0.31,0.296,0.805-0.012,1.105L7.83,15.928c-0.152,0.148-0.35,0.223-0.547,0.223c-0.203,0-0.406-0.08-0.559-0.236c-0.303-0.309-0.295-0.803,0.012-1.104L11.611,10.049z\"></path>\n                 </svg>`,\n    \n    addTask: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n              <path fill=\"none\" d=\"M13.388,9.624h-3.011v-3.01c0-0.208-0.168-0.377-0.376-0.377S9.624,6.405,9.624,6.613v3.01H6.613c-0.208,0-0.376,0.168-0.376,0.376s0.168,0.376,0.376,0.376h3.011v3.01c0,0.208,0.168,0.378,0.376,0.378s0.376-0.17,0.376-0.378v-3.01h3.011c0.207,0,0.377-0.168,0.377-0.376S13.595,9.624,13.388,9.624z M10,1.344c-4.781,0-8.656,3.875-8.656,8.656c0,4.781,3.875,8.656,8.656,8.656c4.781,0,8.656-3.875,8.656-8.656C18.656,5.219,14.781,1.344,10,1.344z M10,17.903c-4.365,0-7.904-3.538-7.904-7.903S5.635,2.096,10,2.096S17.903,5.635,17.903,10S14.365,17.903,10,17.903z\"></path>\n              </svg>`,\n\n    editTask: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n               <path d=\"M10,2.172c-4.324,0-7.828,3.504-7.828,7.828S5.676,17.828,10,17.828c4.324,0,7.828-3.504,7.828-7.828S14.324,2.172,10,2.172M10,17.004c-3.863,0-7.004-3.141-7.004-7.003S6.137,2.997,10,2.997c3.862,0,7.004,3.141,7.004,7.004S13.862,17.004,10,17.004M10,8.559c-0.795,0-1.442,0.646-1.442,1.442S9.205,11.443,10,11.443s1.441-0.647,1.441-1.443S10.795,8.559,10,8.559 M10,10.619c-0.34,0-0.618-0.278-0.618-0.618S9.66,9.382,10,9.382S10.618,9.661,10.618,10S10.34,10.619,10,10.619 M14.12,8.559c-0.795,0-1.442,0.646-1.442,1.442s0.647,1.443,1.442,1.443s1.442-0.647,1.442-1.443S14.915,8.559,14.12,8.559 M14.12,10.619c-0.34,0-0.618-0.278-0.618-0.618s0.278-0.618,0.618-0.618S14.738,9.661,14.738,10S14.46,10.619,14.12,10.619 M5.88,8.559c-0.795,0-1.442,0.646-1.442,1.442s0.646,1.443,1.442,1.443S7.322,10.796,7.322,10S6.675,8.559,5.88,8.559 M5.88,10.619c-0.34,0-0.618-0.278-0.618-0.618S5.54,9.382,5.88,9.382S6.498,9.661,6.498,10S6.22,10.619,5.88,10.619\"></path>\n               </svg>`,\n    \n    deleteTask: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n                 <path d=\"M17.114,3.923h-4.589V2.427c0-0.252-0.207-0.459-0.46-0.459H7.935c-0.252,0-0.459,0.207-0.459,0.459v1.496h-4.59c-0.252,0-0.459,0.205-0.459,0.459c0,0.252,0.207,0.459,0.459,0.459h1.51v12.732c0,0.252,0.207,0.459,0.459,0.459h10.29c0.254,0,0.459-0.207,0.459-0.459V4.841h1.511c0.252,0,0.459-0.207,0.459-0.459C17.573,4.127,17.366,3.923,17.114,3.923M8.394,2.886h3.214v0.918H8.394V2.886z M14.686,17.114H5.314V4.841h9.372V17.114z M12.525,7.306v7.344c0,0.252-0.207,0.459-0.46,0.459s-0.458-0.207-0.458-0.459V7.306c0-0.254,0.205-0.459,0.458-0.459S12.525,7.051,12.525,7.306M8.394,7.306v7.344c0,0.252-0.207,0.459-0.459,0.459s-0.459-0.207-0.459-0.459V7.306c0-0.254,0.207-0.459,0.459-0.459S8.394,7.051,8.394,7.306\"></path>\n                 </svg>`,\n\n    closeEditor: `<svg class=\"svg-icon\" viewBox=\"0 0 20 20\">\n                <path fill=\"none\" d=\"M13.864,6.136c-0.22-0.219-0.576-0.219-0.795,0L10,9.206l-3.07-3.07c-0.219-0.219-0.575-0.219-0.795,0\n                    c-0.219,0.22-0.219,0.576,0,0.795L9.205,10l-3.07,3.07c-0.219,0.219-0.219,0.574,0,0.794c0.22,0.22,0.576,0.22,0.795,0L10,10.795\n                    l3.069,3.069c0.219,0.22,0.575,0.22,0.795,0c0.219-0.22,0.219-0.575,0-0.794L10.794,10l3.07-3.07\n                    C14.083,6.711,14.083,6.355,13.864,6.136z M10,0.792c-5.086,0-9.208,4.123-9.208,9.208c0,5.085,4.123,9.208,9.208,9.208\n                    s9.208-4.122,9.208-9.208C19.208,4.915,15.086,0.792,10,0.792z M10,18.058c-4.451,0-8.057-3.607-8.057-8.057\n                    c0-4.451,3.606-8.057,8.057-8.057c4.449,0,8.058,3.606,8.058,8.057C18.058,14.45,14.449,18.058,10,18.058z\"></path>\n                </svg>`,\n    oopsError: `<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"oopsError\" enable-background=\"new 0 0 512 512\" height=\"80\" viewBox=\"0 0 512 512\" width=\"80\">\n    <g>\n        <path d=\"m211 165c0-40.58-32.401-73.712-72.688-74.941-.766-.039-1.536-.059-2.312-.059s-1.546.02-2.312.059c-40.287 1.229-72.688 34.361-72.688 74.941 0 41.355 33.645 75 75 75s75-33.645 75-75zm-60-30c0 8.271-6.729 15-15 15s-15-6.729-15-15 6.729-15 15-15 15 6.729 15 15zm-15 75c-24.813 0-45-20.187-45-45 0-5.258.915-10.305 2.58-15 6.192 17.459 22.865 30 42.42 30s36.228-12.541 42.42-30c1.665 4.695 2.58 9.742 2.58 15 0 24.813-20.187 45-45 45z\"/>\n        <path d=\"m451 165c0-40.58-32.401-73.712-72.688-74.941-.766-.039-1.536-.059-2.312-.059s-1.546.02-2.313.059c-40.286 1.229-72.687 34.361-72.687 74.941 0 41.355 33.645 75 75 75s75-33.645 75-75zm-60-30c0 8.271-6.729 15-15 15s-15-6.729-15-15 6.729-15 15-15 15 6.729 15 15zm-15 75c-24.813 0-45-20.187-45-45 0-5.258.915-10.305 2.58-15 6.192 17.459 22.865 30 42.42 30s36.228-12.541 42.42-30c1.665 4.695 2.58 9.742 2.58 15 0 24.813-20.187 45-45 45z\"/>\n        <path d=\"m301 315v15h30v-15c0-41.355-33.645-75-75-75s-75 33.645-75 75v15h30v-15c0-24.813 20.187-45 45-45s45 20.187 45 45z\"/>\n        <path d=\"m76 362c-24.813 0-45 20.187-45 45v60c0 24.813 20.187 45 45 45s45-20.187 45-45v-60c0-24.813-20.187-45-45-45zm15 105c0 8.271-6.729 15-15 15s-15-6.729-15-15v-60c0-8.271 6.729-15 15-15s15 6.729 15 15z\"/>\n        <path d=\"m196 362c-24.813 0-45 20.187-45 45v60c0 24.813 20.187 45 45 45s45-20.187 45-45v-60c0-24.813-20.187-45-45-45zm15 105c0 8.271-6.729 15-15 15s-15-6.729-15-15v-60c0-8.271 6.729-15 15-15s15 6.729 15 15z\"/>\n        <path d=\"m316 362h-45v150h30v-60h15c24.813 0 45-20.187 45-45s-20.187-45-45-45zm0 60h-15v-30h15c8.271 0 15 6.729 15 15s-6.729 15-15 15z\"/>\n        <path d=\"m436 422c-8.271 0-15-6.729-15-15s6.729-15 15-15c4.006 0 7.773 1.56 10.607 4.394l10.607 10.606 21.213-21.214-10.607-10.606c-8.5-8.499-19.8-13.18-31.82-13.18-24.813 0-45 20.187-45 45s20.187 45 45 45c8.271 0 15 6.729 15 15s-6.729 15-15 15c-4.006 0-7.773-1.56-10.607-4.394l-10.607-10.606-21.213 21.214 10.607 10.606c8.5 8.499 19.8 13.18 31.82 13.18 24.813 0 45-20.187 45-45s-20.187-45-45-45z\"/>\n        <path d=\"m211 15v-15h-30v15c0 24.813-20.187 45-45 45h-75v30h75c41.355 0 75-33.645 75-75z\"/>\n        <path d=\"m451 60h-75c-24.813 0-45-20.187-45-45v-15h-30v15c0 41.355 33.645 75 75 75h75z\"/>\n    </g>\n</svg>`\n}\n\n\nmodule.exports = {svgPaths}\n\n\n//# sourceURL=webpack:///./svgpaths.js?");

/***/ }),

/***/ "./tools.js":
/*!******************!*\
  !*** ./tools.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const CONFIG = __webpack_require__(/*! ./config */ \"./config.js\")\nconst LOCALE = CONFIG.LOCALE\n\n\n/**\n *                           MISC                           \n ************************************************************/\n\nfunction copyObject(object) {\n    let newCopy = {}\n    Object.assign(newCopy, object)\n    return newCopy\n}\n\n/**\n * Simple function to compare two arrays\n * @param  {Array} a - first array\n * @param  {Array} b - second array\n */\nfunction arraysEquals(a, b) {\n    return (a.length === b.length\n            && a.every((v, i) => v === b[i]))\n}\n\n/**\n * Recursive traverse of child nodes of the given HTML element.\n * @param  {object} element - html element\n * @param  {function} handler - function to handle descendants of the given element\n * @param  {Array} exclusions - list of nodes to exclude during traversal\n */\nfunction traverseNodeChildren(element, handler, exclusions = []) {\n    if (element.childElementCount < 1) {\n        return\n    }\n    element.childNodes.forEach(childNode => {\n        if (!exclusions.includes(childNode)) {\n            traverseNodeChildren(childNode, handler, exclusions)\n        }\n    })\n    element.childNodes.forEach(childNode => {\n        handler(childNode)\n    })\n}\n\n\n/*                        NETWORK                           \n ************************************************************/\n\nfunction getCookie(name) {\n    let cookieValue = null\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';')\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim()\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1))\n                break\n            }\n        }\n    }\n    return cookieValue\n}\n\n\n/*           WORKING WITH DATES AND RELATED TO IT                           \n ************************************************************/\n\n/**\n * Function to make a Date from given value, if it isn't\n * already type of Date.\n */\nfunction toDateField(date) {\n    if (date instanceof Date) {\n        return date\n    } else if (typeof date === 'string') {\n        const dateObject = new Date(date)\n\n        if (isNaN(dateObject.getDate())) {\n            throw new TypeError('cannot make valid Date object ' +\n                `from \"${date}\"`)\n        } else {\n            return dateObject\n        }\n    }\n    else {\n        throw new TypeError('cannot make valid Date object ' +\n            `from \"${date}\" - only Date objects ` +\n            'and strings are allowed as args')\n    }\n}\n\nfunction resetTimezone(date) {\n    let timezoneOffset = date.getTimezoneOffset() * 60 * 1000\n    let newDate = new Date(date.getTime() - timezoneOffset)\n    return newDate\n}\n\nconst DateFormat = {\n    monthLabel: (dateObj, locale=LOCALE) => {\n        return new Intl.DateTimeFormat(locale.languageTag, {\n            month: 'long',\n            year: 'numeric'\n        }).format(dateObj)\n    },\n    dateLabel: (dateObj, locale=LOCALE) => {\n        return new Intl.DateTimeFormat(locale.languageTag, {\n            weekday: 'short',\n            day: 'numeric',\n            month: 'short',\n            year: 'numeric'\n        }).format(dateObj)\n    },\n    /** Make ISO string with trailing \"+00:00\" for a Date() object.\n     * (e.g.'2021-02-01T00:00:00+00:00' instead of '2021-02-01T00:00:00Z'\n     * as in the standard Date.toISOString() method). \n     * @param  {Date} dateObj\n     */\n    toProperISOString: (dateObj) => {\n        let jsISOString = dateObj.toISOString()\n        let properISOString = jsISOString.replace('Z', '+00:00')\n        return properISOString\n    }\n}\n\n\n/*               LANGUAGES AND TRANSLATIONS                           \n ************************************************************/\n\n/**\n * Takes a string in english and object of locale with\n * translations and returns translated string.\n * Example:\n * ```\n * const DE = {'Good morning': 'Guten Morgen'}\n * translate('Good morning', DE) // 'Guten Morgen'\n * ```\n * @param  {string} str\n * @param  {object} lang\n */\nfunction translate(str, locale=LOCALE) {\n    let translation = locale.lines[str]\n    if (typeof translation === 'string') {\n        return translation\n    } else {\n        console.error('no such line in the lines collection ' +\n            'or wrong type of string provident:', str)\n        return str\n    }\n}\n\n\nmodule.exports = {\n    copyObject, getCookie, toDateField, arraysEquals,\n    translate, DateFormat: DateFormat, resetTimezone,\n    traverseNodeChildren\n}\n\n\n//# sourceURL=webpack:///./tools.js?");

/***/ }),

/***/ "./transportservice.js":
/*!*****************************!*\
  !*** ./transportservice.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const CONFIG = __webpack_require__(/*! ./config */ \"./config.js\")\nconst { getCookie } = __webpack_require__(/*! ./tools.js */ \"./tools.js\")\nconst { MissingServerError } = __webpack_require__(/*! ./errors */ \"./errors.js\")\n\n\nclass TransportService {\n    constructor(serverURLs = CONFIG.SERVER_URLs) {\n        this.urls = serverURLs\n    }\n\n    /**\n     * Request from server JSON file consisting of: \n     * 1) list of all days in the month of specified date (as\n     * ISOStrings). List contains extra-days to make 6 full weeks and\n     * look as a pretty calendar (used in Calendar widget);\n     * 2) All user tasks for this month including repeated by specified\n     * time interval.\n     * @param  {Date} date\n     */\n    getMonthPack(date) {\n        let httpParamDate = date.toISOString().replace('Z', '+00:00')\n\n        let url = new URL(this.urls.changeDate, this.urls.base)\n        url.searchParams.append('date', httpParamDate)\n\n        // return fetch(url)\n        //     .then(response => response.json())\n        return fetch(url)\n            .then(response => {\n                console.log(response.status)\n                if (!response.ok) {\n                    throw new Error(\"HTTP status \" + response.status)\n                }\n                return response.json()\n            })\n            .catch(err => {\n                throw new MissingServerError('server does not answer:' + err.message)\n            })\n    }\n\n    addNewTask(task) {\n        const url = new URL(this.urls.tasks + '/', this.urls.base)\n        return fetch(url, {\n            method: 'POST',\n            mode: 'cors',\n            credentials: 'same-origin',\n            headers: {\n                'X-CSRFToken': getCookie('csrftoken'),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(task)\n        })\n    }\n\n    deleteTask(taskID) {\n        const url = new URL(this.urls.tasks + `/${taskID}`, this.urls.base)\n        return fetch(url, {\n            method: 'DELETE',\n            mode: 'cors',\n            credentials: 'same-origin',\n            headers: {\n                'X-CSRFToken': getCookie('csrftoken'),\n            },\n        })\n    }\n\n    changeTask(task, checkUncheck = false) {\n        const url = new URL(this.urls.tasks + `/${task.id}/`, this.urls.base)\n        let reqInit = {\n            method: 'PUT',\n            mode: 'cors',\n            credentials: 'same-origin',\n            headers: {\n                'X-CSRFToken': getCookie('csrftoken'),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(task)\n        }\n\n        if (checkUncheck) {\n            reqInit.headers['checkUncheck'] = 1\n        }\n\n        return fetch(url, reqInit)\n    }\n}\n\n\nmodule.exports = { TransportService }\n\n\n//# sourceURL=webpack:///./transportservice.js?");

/***/ }),

/***/ "./widgets/widget.calendar.js":
/*!************************************!*\
  !*** ./widgets/widget.calendar.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Widget } = __webpack_require__(/*! ./widget */ \"./widgets/widget.js\")\nconst { IconButton24 } = __webpack_require__(/*! ./widget.common */ \"./widgets/widget.common.js\")\nconst { svgPaths } = __webpack_require__(/*! ../svgpaths */ \"./svgpaths.js\")\nconst { DateFormat, resetTimezone } = __webpack_require__(/*! ../tools */ \"./tools.js\")\n\n\nclass Calendar extends Widget {\n    constructor(parent, cacheService) {\n        super(parent)\n\n        this.id = 'c-calendar'\n        this.cacheService = cacheService\n\n        this.date = this.cacheService.pageDate\n        this.daysArr = this.cacheService.datesArray\n\n        // Child widgets\n        this.childWidgets = [\n            this.Topbar = new Widget(this, { id: 'c-topbar' }),\n\n            this.DaysFrame = new Widget(this, { id: 'c-daysFrame' }),\n\n            this.PrevMonthBtn = new IconButton24(this.Topbar, {\n                id: 'monthBack-bt',\n                onclick: this.toPrevMonth.bind(this),\n            }, svgPaths.pointLeft),\n\n            this.MonthLabel = new Widget(this.Topbar, {\n                id: 'c-topbar__monthLabel',\n                innerText: DateFormat.monthLabel(this.date)\n            }),\n\n            this.NextMonthBtn = new IconButton24(this.Topbar, {\n                id: 'monthForv-bt',\n                onclick: this.toNextMonth.bind(this),\n            }, svgPaths.pointRight),\n        ]\n\n        this.DayButtonArr = this.initDayButtons(this.DaysFrame, this.daysArr)\n\n        // some cosmetic appearance fixes\n        this.PrevMonthBtn.addCssClass('c-topbar__swtcMonthBt')\n        this.NextMonthBtn.addCssClass('c-topbar__swtcMonthBt')\n    }\n\n    build() {\n        super.build()\n        this.childWidgets.forEach(ch => ch.build())\n        this.DayButtonArr.forEach(btn => btn.build())\n    }\n\n    initDayButtons(frame, daysArr) {\n        let array = []\n        for (let date of daysArr) {\n            let btn = new DayButton(frame, date, this.cacheService)\n            array.push(btn)\n        }\n        return array\n    }\n\n    configurateDayButtons(newDateList) {\n        let index = 0\n        for (let btn of this.DayButtonArr) {\n            btn.configurate(newDateList[index])\n            index += 1\n        }\n    }\n\n    updDayButtonsStatus() {\n        this.DayButtonArr.forEach(bt => bt.updStatus())\n    }\n\n    reqChangeDate(newDate) {\n        this.cacheService.setPageDate(newDate)\n            .then(() => {\n                this.date = this.cacheService.pageDate\n                this.daysArr = this.cacheService.datesArray\n                this.configurateDayButtons(this.daysArr)\n                this.MonthLabel.element.innerText = DateFormat.monthLabel(this.date)\n            })\n            .catch(err => {\n                // TODO: proper error handling \n                console.log('error catched in the end-point')\n                throw err\n            })\n    }\n\n    toNextMonth() {\n        let newMonth, newYear\n        if (this.date.getMonth() === 11) {\n            newMonth = 0\n            newYear = this.date.getYear() + 1 + 1900\n        } else {\n            newMonth = this.date.getMonth() + 1\n            newYear = this.date.getYear() + 1900\n        }\n\n        let newDate = new Date(newYear, newMonth)\n        this.reqChangeDate(resetTimezone(newDate))\n    }\n\n    toPrevMonth() {\n        let newMonth, newYear\n        if (this.date.getMonth() === 0) {\n            newMonth = 11\n            newYear = this.date.getYear() - 1 + 1900\n        } else {\n            newMonth = this.date.getMonth() - 1\n            newYear = this.date.getYear() + 1900\n        }\n\n        let newDate = new Date(newYear, newMonth)\n        this.reqChangeDate(resetTimezone(newDate))\n    }\n\n    refreshMonth() {\n        this.reqChangeDate(this.date)\n    }\n\n}\n\n\nclass DayButton extends Widget {\n    constructor(parent, date, cacheService) {\n        super(parent)\n        this.tag = 'button'\n        this.element = document.createElement(this.tag)\n        this.id = this.makeId('dBtn')\n        this.element.className = 'c-daysFrame__dayButton'\n\n        this.cacheService = cacheService\n        this.date = date\n\n        this.options = {\n            onclick: this.boundSelf.bind(this),\n        }\n\n        this.configurate(this.date)\n    }\n\n    updStatus() {\n        let status = this.cacheService.tasksArray.checkDailyTasks(this.date)\n        let classList = this.element.classList  // shortcut\n\n        if (status === 'no tasks') {\n            classList.add('--no-tasks')\n            classList.remove('--tasks-done', '--got-tasks')\n        } else if (status === 'tasks done') {\n            classList.add('--tasks-done')\n            classList.remove('--no-tasks', '--got-tasks')\n        } else if (status === 'got tasks') {\n            classList.add('--got-tasks')\n            classList.remove('--no-tasks', '--tasks-done')\n        } else {\n            throw 'no such status: ' + status\n        }\n    }\n\n    configurate(newDate) {\n        this.date = newDate\n        this.element.innerText = newDate.getDate()\n\n        this.updStatus()\n        if (this.date.getMonth() != this.cacheService.pageDate.getMonth()) {\n            this.element.classList.add('--out-month')\n        } else {\n            this.element.classList.remove('--out-month')\n        }\n    }\n\n    reqChangeDate(newDate) {\n        this.date = newDate\n        this.configurate(newDate)\n    }\n\n    reachTaskPanel() {\n        let taskPanel = Widget.instanceList['tp-taskpanel']\n        if (!taskPanel) {\n            throw 'DayButton on the calendar cannot reach taskPanel ' + \n                  `widget by id \"tp-taskpanel\": ${this.id}`\n        }\n        return taskPanel\n    }\n\n    boundSelf() {\n        const taskPanel = this.reachTaskPanel()\n        taskPanel.boundDayBt(this)\n    }\n\n}\n\n\nmodule.exports = { DayButton, Calendar }\n\n//# sourceURL=webpack:///./widgets/widget.calendar.js?");

/***/ }),

/***/ "./widgets/widget.common.js":
/*!**********************************!*\
  !*** ./widgets/widget.common.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Widget } = __webpack_require__(/*! ./widget */ \"./widgets/widget.js\")\nconst { translate } = __webpack_require__(/*! ../tools */ \"./tools.js\")\n\n\nclass IconButton24 extends Widget {\n    constructor(parent, options = {}, svgHTML) {\n        super(parent, options)\n        this.tag = 'button'\n        this.element = document.createElement(this.tag)\n        this.element.className = 'button-icon24'\n\n        this.SvgIcon = Widget.fromHTML(this, svgHTML)\n    }\n\n    build() {\n        super.build()\n        this.SvgIcon.build()\n        if (this.defaultOptions.onclick) {\n            this.element.onclick = this.defaultOptions.onclick\n        }\n        if (this.defaultOptions.context) {\n            this.element.context = this.defaultOptions.context\n        }\n    }\n}\n\n/**\n * Constructor of the Widget takes two args: parent Widget and\n * optionList which should be represented as an array of arrays.\n * Each nested array must consists of two items: \n * 1) value attr of html <option> element;\n * 2) inner text of <option>.\n * @param  {Widget} parent\n * @param  {object} optionsList\n */\nclass Select extends Widget {\n    constructor(parent, optionsList) {\n        super(parent)\n        this.tag = 'select'\n        this.element = document.createElement(this.tag)\n        this.optionsList = this.initOptions(optionsList)\n        this.defaultValue\n    }\n\n    get value() {\n        return this.element.value\n    }\n\n    set value(newValue) {\n        this.element.value = newValue\n    }\n\n    initOptions(optionsList) {\n        let optionWidgets = []\n        optionsList.forEach(pair => {\n            let value = pair[0]\n            let text = translate(pair[1])\n            const optionWidget = new Widget(this, {\n                tagName: 'option',\n                value: value,\n                text: text\n            })\n            optionWidgets.push(optionWidget)\n        })\n        return optionWidgets\n    }\n\n    build() {\n        super.build()\n        this.optionsList.forEach(opt => opt.build())\n\n        if (this.defaultValue) {\n            this.value = this.defaultValue\n        }\n    }\n}\n\nmodule.exports = { IconButton24, Select }\n\n//# sourceURL=webpack:///./widgets/widget.common.js?");

/***/ }),

/***/ "./widgets/widget.js":
/*!***************************!*\
  !*** ./widgets/widget.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { copyObject } = __webpack_require__(/*! ../tools */ \"./tools.js\")\n\n\n// stores all widgets added to the document\nconst _WIDGETS_REGISTRY = {}\n\n\n/**\n* The base class for widget entity, that combine simple\n* html element and logic of its behavior with attached data \n* to provide this logic.\n* @param  {Widget} parent - where to place this \n* @param  {object} options={ } - options of HTML Element\n*/\nclass Widget {\n    constructor(parent, options = {}) {\n        this._checkTypes(parent, options)\n\n        // Parent widget\n        this.parent = parent\n        // HTML Element associated with this class instance \n        this.element = document.createElement(\n            options.tagName ? options.tagName : 'DIV'\n        )\n        // HTML Element attributes you may specify before initialization\n        this.options = options\n        // HTML id attribute and id of this class instance.\n        this.id = options.id ? options.id : this.makeId('w')\n        // Variable to keep available the parameters that were set during\n        // initialization of this.\n        this.defaultOptions = copyObject(options)\n\n        //                          Privates\n\n        // Flex, block, etc. Private parameter to use it in this.hide()\n        // and this.show() methods.\n        this._defaultDisplayMode\n    }\n\n    set options(newOptions) {\n        delete newOptions.tagName\n        try {\n            Object.assign(this.element, newOptions)\n        } catch (err) {\n            console.error(`cannot assign given options ${newOptions} to the`\n                + `HTML element of the Widget`)\n            throw err\n        }\n    }\n\n    /**\n     * The alternative constructor, that takes as args parent `Widget`\n     * and raw html string and returns a new Widget object based on\n     * given html string.\n     * @param  {Widget} parent  -  where to place this \n     * @param  {string} rawHTML  -  e.g `\"<div>example</div>\"`\n     * @returns {Widget} Widget\n     */\n    static fromHTML(parent, rawHTML) {\n        let newElement = this.makeElementFromHTML(rawHTML)\n        let newWidget = new Widget(parent)\n        newWidget.element = newElement\n        return newWidget\n    }\n\n    /**\n     * Creates HTML Element from a raw string.\n     * \n     * @param  {string} rawHTML  -  e.g `\"<div>example</div>\"`\n     */\n    static makeElementFromHTML(rawHTML) {\n        let parser = new DOMParser()\n        let newDoc = parser.parseFromString(rawHTML, 'text/html')\n        let element = newDoc.body.firstElementChild\n        return element\n    }\n\n    /**\n     * Places `this.element` inside the specified parent widget\n     * (renders it).\n     */\n    build() {\n        try {\n            this.element.id = this.id\n            let parentNode = document.getElementById(this.parent.id)\n            parentNode.insertAdjacentElement('beforeend', this.element)\n            this._defaultDisplayMode = this.element.style.display\n            _WIDGETS_REGISTRY[this.id] = this\n        } catch (err) {\n            console.error('cannot build Widget:', this)\n            throw (err)\n        }\n    }\n\n    /**\n     * Is `this.element` already on the page?\n     */\n    isBuilded() {\n        if (document.getElementById(this.id)) {\n            return true\n        } else {\n            return false\n        }\n    }\n\n    /**\n     * Make id for this instance from some random integers and \n     * the character which will be concatenated to this integers\n     * (may use to represent type of this `Widget`, for example).\n     * ```\n     * // Usage:\n     * this.makeID('MyWidgetType') // 'MyWidgetType14336'\n     * \n     * this.makeID('w') // 'w54023'\n     * ```\n     * @param  {string} typeChar  - \n     */\n    makeId(typeChar) {\n        let randInt = Math.floor(Math.random() * 99999)\n        return typeChar + randInt\n    }\n\n    /**\n     * Removes HTML element of this `Widget` from the document.\n     * Can be restored via this.build() \n     */\n    remove() {\n        delete _WIDGETS_REGISTRY[this.id]\n        this.element.remove()\n    }\n\n    /**\n     * Set `this.element.style.display` to 'none' - hides im from the page\n     */\n    hide() {\n        if (this._defaultDisplayMode != 'none') {\n            let currentMode = this.element.style.display\n            this.element._defaultDisplayMode = currentMode\n        }\n        this.element.style.display = 'none'\n    }\n\n    /**\n     * Sets this.element.style.display to the value, that was\n     * given during initialization of this Widget instance\n     */\n    show() {\n        this.element.style.display = this._defaultDisplayMode\n    }\n\n    /**\n     * Make user unable to interact with this.element on the page\n     */\n    disable() {\n        this.element.disabled = true\n    }\n\n    /**\n     * Make user able to interact with this.element on the page (if it was\n     * disabled)\n     */\n    enable() {\n        this.element.disabled = false\n    }\n\n    addCssClass(className) {\n        this.element.classList.add(className)\n    }\n\n    removeCssClass(className) {\n        this.element.classList.remove(className)\n    }\n    \n    /**\n     * get an object where keys are identifiers of all Widgets (and id\n     * of their html elements either) added to the document and values\n     * are corresponding widget objects.\n     */\n    static get instanceList() {\n        return _WIDGETS_REGISTRY\n    }\n\n    /**\n     * Validate args of the class constructor.\n     * \n     * @param  {Widget} parent\n     * @param  {object} options\n     */\n    _checkTypes(parent, options) {\n        if (\n            !(parent instanceof Widget)\n            & (parent.id != '_main-container')\n        ) {\n            throw new TypeError('first argument (parent) should ' +\n                'be an instance of Widget')\n        }\n    }\n}\n\n\nmodule.exports = { Widget }\n\n\n//# sourceURL=webpack:///./widgets/widget.js?");

/***/ }),

/***/ "./widgets/widget.popup.js":
/*!*********************************!*\
  !*** ./widgets/widget.popup.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Widget } = __webpack_require__(/*! ./widget */ \"./widgets/widget.js\")\nconst { translate, traverseNodeChildren } = __webpack_require__(/*! ../tools */ \"./tools.js\")\n\n\nclass PopUpWindow extends Widget {\n    constructor(options) {\n        super(options.parent)\n        this.cssClass = options.cssClass\n        this.onclose = options.onclose\n        if (options.caption) {\n            this.Caption = new Widget(this, {\n                className: 'popup-caption',\n                innerText: options.caption\n            })\n        }\n        if (options.svgPicture) {\n            this.SvgPicture = Widget.fromHTML(this, options.svgPicture)\n        }\n        if (!options.irreversible) {\n            this.ConformButton = new Widget(this, {\n                tagName: 'button',\n                innerText: translate('ok'),\n                onclick: this.close.bind(this)\n            })\n        }\n    }\n\n    build() {\n        super.build()\n        this.addCssClass('popup')       \n        if (this.cssClass) {\n            this.addCssClass(this.cssClass)\n        }     \n        if (this.SvgPicture) {\n            this.SvgPicture.build()\n        }      \n        if (this.Caption) {\n            this.Caption.build()     \n        }\n        if (this.ConformButton) {\n            this.ConformButton.build()\n        }    \n        this.setDisabledForParent(true)\n    }\n\n    close() {\n        if (this.onclose) {\n            this.onclose()\n        }\n        this.setDisabledForParent(false)\n        this.remove()\n    }\n\n    /**\n     * Recursively traverse all child nodes of a parent Widget html\n     * element and disable (enable) all its nodes according to given\n     * boolean flag\n     * @param  {boolean} flag - if true - disable, false - enable\n     */\n    setDisabledForParent(flag) {\n        if (typeof flag != 'boolean') {\n            throw TypeError('the function requires a boolean ' +\n                            'value as an argument')\n        }\n        \n        let parentNode\n        if (this.parent.id === '_main-container') {\n            parentNode = this.parent\n        } else {\n            parentNode = this.parent.element\n        }\n        // recursively traverse all child nodes of a parent Widget\n        // element and disable (enable) all its nodes\n        traverseNodeChildren(parentNode, childNode => {\n            childNode.disabled = flag\n        }, [this.element])\n        // dim (or brighten) parent node to make it look disabled (active)\n        parentNode.childNodes.forEach(childNode => {\n            if(childNode != this.element) {\n                if (flag) {\n                    childNode.style.filter = 'brightness(0.5)';\n                } else {\n                    childNode.style.filter = 'brightness(1)'\n                }\n            } \n        })\n    }\n}\n\nmodule.exports = { PopUpWindow }\n\n\n//# sourceURL=webpack:///./widgets/widget.popup.js?");

/***/ }),

/***/ "./widgets/widget.taskpanel.js":
/*!*************************************!*\
  !*** ./widgets/widget.taskpanel.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Widget } = __webpack_require__(/*! ./widget */ \"./widgets/widget.js\")\nconst { IconButton24, Select } = __webpack_require__(/*! ./widget.common */ \"./widgets/widget.common.js\")\nconst { svgPaths } = __webpack_require__(/*! ../svgpaths */ \"./svgpaths.js\")\nconst { DateFormat, translate } = __webpack_require__(/*! ../tools */ \"./tools.js\")\n\n\nclass TaskPanel extends Widget {\n    constructor(parent, cacheService) {\n        super(parent)\n\n        this.id = 'tp-taskpanel'\n        this.cacheService = cacheService\n\n        // the appropriate DayButton on the calendar widget, which have\n        // the same date\n        this.relatedDayButton\n\n        // Child widgets\n        this.Topbar = new Widget(this, {\n            id: 'tp-topbar',\n        })\n        this.DateLabel = new Widget(this.Topbar, {\n            id: 'tp-dateLabel',\n            innerText: ''\n        })\n        this.TaskList = new TaskList(this)\n\n        this.CreateTaskBt = new IconButton24(this.Topbar, {\n            id: 'tp-createTaskBt',\n            onclick: this.TaskList.openTaskAdder.bind(this.TaskList)\n        }, svgPaths.addTask)\n\n    }\n\n    get dailyTaskArray() {\n        if (this.relatedDayButton) {\n            let date = this.relatedDayButton.date\n            return this.cacheService.tasksArray.getDailyTasks(date)\n        } else {\n            return []\n        }\n    }\n\n    build() {\n        super.build()\n\n        this.Topbar.build()\n        this.DateLabel.build()\n        this.TaskList.build()\n    }\n\n    boundDayBt(dayButton) {\n        this.relatedDayButton = dayButton\n        this.TaskList.update()\n        this.DateLabel.element.innerText = DateFormat.dateLabel(dayButton.date)\n\n        if (!this.CreateTaskBt.isBuilded()) {\n            this.CreateTaskBt.build()\n        }\n    }\n\n}\n\n\nclass TaskList extends Widget {\n    constructor(parent) {\n        super(parent)\n        this.parent = parent\n        this.id = 'tp-taskList'\n        this.cacheService = this.parent.cacheService\n        this.options = { innerText: translate('No tasks') }\n\n        this.taskItemArray = this.initTaskItems()\n    }\n\n    initTaskItems() {\n        let tasksToShow = this.taskArray\n        if (tasksToShow) {\n            let itemsArray = []\n            for (let task of tasksToShow) {\n                let taskItem = new TaskItem(this, task)\n                itemsArray.push(taskItem)\n            }\n            return itemsArray\n        }\n    }\n\n    build() {\n        super.build()\n        this.makeListObserver()\n        this.buildTaskItems()\n\n    }\n\n    buildTaskItems() {\n        if (this.taskItemArray) {\n            this.taskItemArray.forEach(taskItem => taskItem.build())\n        }\n    }\n    /**\n     * creates a MutationObserver object that keeps track of the number\n     * of tasks items in the TaskList div. If it becomes 0, the message\n     * “all tasks completed” will be displayed.\n     */\n    makeListObserver() {\n        const itemsObserver = new MutationObserver((mutationsList, observer) => {\n            for (let mutation of mutationsList) {\n                if (!mutation.target.childElementCount) {\n                    mutation.target.style.fontSize = '18px'\n                } else {\n                    mutation.target.style.fontSize = '0px'\n                }\n                return\n            }\n        })\n        const observerConfig = { attributes: false, childList: true, subtree: false }\n        itemsObserver.observe(this.element, observerConfig)\n    }\n\n    clear() {\n        this.taskItemArray.forEach(taskItem => taskItem.remove())\n    }\n\n    update() {\n        this.clear()\n        this.taskItemArray = this.initTaskItems()\n        this.buildTaskItems()\n    }\n\n\n    openTaskAdder() {\n        let adder = new TaskAdder(this)\n        this.taskItemArray.push(adder)\n        adder.build()\n\n    }\n\n    get relatedDayButton() {\n        return this.parent.relatedDayButton\n    }\n\n    get taskArray() {\n        return this.parent.dailyTaskArray\n    }\n\n    get date() {\n        return this.parent.relatedDayButton.date\n    }\n\n}\n\n\nclass TaskItem extends Widget {\n    constructor(parent, taskObj) {\n        super(parent)\n\n        this.parent = parent\n        this.cacheService = this.parent.cacheService\n        this.taskObj = taskObj ? taskObj : this._emptyTaskObj\n        this.id = this.makeId('ti')\n        this.element.className = 'tp-taskitem'\n\n        // checkbox to mark the task as completed or vice versa\n        this.checkDone = new Widget(this, {\n            tagName: 'input',\n            className: 'tp-taskCheckout',\n            type: 'checkbox',\n            checked: this.taskObj.completion,\n            onclick: this.checkUncheckCompletion.bind(this)\n        }),\n\n            // container for a divs that displays the title and description\n            // of the task or widgets for the user to edit the task\n            this.Main = new Widget(this, {\n                className: 'tp-taskitemMain'\n            })\n\n\n        // divs that displays task's title and description\n        this.defaultWidgets = [\n            this.Title = new Widget(this.Main, {\n                className: 'tp-taskitemTitle',\n                innerText: this.taskObj.title\n            }),\n            this.Description = new Widget(this.Main, {\n                className: 'tp-taskitemDescr',\n                innerText: this.taskObj.description,\n            }),\n\n        ]\n\n        // widgets for editing task fields (user input)\n        this.editingWidgets = [\n\n            this.SaveCloseCont = new Widget(this.Main, {\n                className: 'tp-taskitemSaveClose',\n            }),\n            this.SaveButton = new IconButton24(this.SaveCloseCont, {\n                className: 'save_task',\n                onclick: this.saveInputValues.bind(this)\n            }, svgPaths.saveTask),\n            this.CloseEditorButton = new IconButton24(this.SaveCloseCont, {\n                className: 'closeEditor',\n                onclick: this.switchToDefaultMode.bind(this),\n            }, svgPaths.closeEditor),\n\n            this.TaskTimeSettingsCont = new Widget(this.Main, {\n                className: 'tp-taskTimeSettings'\n            }),\n            this.DateSettings = new TaskSettingsElement(\n                this.TaskTimeSettingsCont,\n                'date', this.taskObj, translate('Postpone:')\n            ),\n            this.IntervalSettings = new TaskSettingsElement(this.TaskTimeSettingsCont,\n                'interval', this.taskObj, translate('Repeat:')),\n            this.AutoshiftSettings = new TaskSettingsElement(this.TaskTimeSettingsCont,\n                'autoshift', this.taskObj, translate('Auto postpone:')),\n\n            this.InputTitle = new TaskSettingsElement(this.Main, 'input', this.taskObj,\n                translate('Task name:')),\n\n            this.InputDescription = new TaskSettingsElement(this.Main, 'textarea', this.taskObj,\n                translate('Description:'))\n        ]\n\n        // buttons 'edit task(switch to editor mode)' and 'delete task'\n        // (located outside the task item's Main container)\n        this.RightButtons = [\n            this.RightButtonsCont = new Widget(this, {\n                className: 'tp-taskitemRightBtns'\n            }),\n            this.EditTaskButton = new IconButton24(this.RightButtonsCont, {\n                className: 'button-icon24',\n                onclick: this.switchToEditMode.bind(this)\n            }, svgPaths.editTask),\n            this.DeleteTaskButton = new IconButton24(this.RightButtonsCont, {\n                className: 'button-icon24',\n                onclick: this.removeSelf.bind(this)\n            }, svgPaths.deleteTask)\n        ]\n    }\n\n    build() {\n        super.build()\n        this.checkDone.build()\n        this.Main.build()\n        this.RightButtons.forEach(wg => wg.build())\n\n        this.SaveButton.addCssClass('ti-SaveTaskBt')\n        this.CloseEditorButton.addCssClass('ti-CloseEditorBt')\n        this.DeleteTaskButton.addCssClass('tp-RightBtnsDelTask')\n        this.EditTaskButton.addCssClass('tp-RightBtnsEditTask')\n\n        this.defaultWidgets.forEach(wg => wg.build())\n    }\n    /**\n     * hides a task's title and description divs and shows the\n     * widgets for editing a task fields and options\n     */\n    switchToEditMode() {\n        this.checkDone.hide()\n        this.RightButtonsCont.hide()\n        this.defaultWidgets.forEach(wg => wg.hide())\n        this.editingWidgets.forEach(wg => {\n            if (!wg.isBuilded()) {\n                wg.build()\n            } else {\n                wg.show()\n            }\n        })\n        this.makeConstraints()\n        this.makeChangesObserver()\n    }\n    /**\n     * hides a task's title and description divs and shows the widgets\n     * for editing a task fields and options\n     */\n    switchToDefaultMode() {\n        this.checkDone.show()\n        this.defaultWidgets.forEach(wg => wg.show())\n        this.editingWidgets.forEach(wg => wg.hide())\n        this.RightButtonsCont.show()\n    }\n    /**\n     * remove the task-item widget from the TaskList widget and\n     * delete related entry about the task in the database\n     */\n    removeSelf() {\n        this.cacheService.deleteTask(this.taskObj)\n            .then(() => {\n                this.remove()\n                // if the task have interval repeat and we need to refresh\n                // all of DayButtons on calendar widget to deleted repeats \n                // that shouldn't exist anymore\n                if (this.taskObj.interval) {\n                    calendar.refreshMonth()\n                } else {\n                    this.relatedDayButton.updStatus()\n                }\n            })\n            .catch(err => {\n                throw err\n            })\n    }\n    /**\n     * returns the values of user input from a task editing widgets\n     */\n    takeInputValues() {\n        return {\n            init_date: new Date(this.DateSettings.value),\n            date: new Date(this.DateSettings.value),\n            interval: this.IntervalSettings.value,\n            autoshift: eval(this.AutoshiftSettings.value),  // \"true\" -> true\n            title: this.InputTitle.value,\n            description: this.InputDescription.value\n        }\n    }\n\n    /**\n     * Updates the text of the divs, that displaying a task's\n     * title and description\n     * @param  {object} newTaskFields\n     */\n    updateFields(newTaskFields) {\n        this.Title.element.innerText = newTaskFields.title\n        this.Description.element.innerText = newTaskFields.description\n    }\n\n    /**\n     * To avoid conflicting states, in a task editing mode:\n     * 1) disables the widgets for date changing and \"auto-postpone until\n     * completion\" when chosen one of a task's interval repeating options;\n     * 2) disables the date changing and 'auto-postpone until completion' \n     * widgets when a task marked as completed in the task settings;\n     * 3) disables the interval choosing widget when 'postpone until\n     * completion' option is active;  \n     */\n    makeConstraints() {\n        const dateInput = this.DateSettings.inputWidget\n        const intervalInput = this.IntervalSettings.inputWidget\n        const autoshiftInput = this.AutoshiftSettings.inputWidget\n        const checkDone = this.checkDone.element\n\n        if (intervalInput.value != 'no' || checkDone.checked) {\n            dateInput.disable()\n            autoshiftInput.disable()\n        } else if (!checkDone.checked) {\n            dateInput.enable()\n            autoshiftInput.enable()\n        }\n        intervalInput.element.addEventListener('change', event => {\n            if (event.target.value != 'no' && !checkDone.checked) {\n                dateInput.disable()\n                autoshiftInput.disable()\n            } else if (!checkDone.checked) {\n                dateInput.enable()\n                autoshiftInput.enable()\n            }\n        })\n\n        if (autoshiftInput.value === 'true') {\n            intervalInput.disable()\n        }\n        autoshiftInput.element.addEventListener('change', event => {\n            if (event.target.value === 'true') {\n                intervalInput.disable()\n            } else {\n                intervalInput.enable()\n            }\n        })\n    }\n\n    makeChangesObserver() {\n        this.editingWidgets.forEach(widget => {\n            if (widget.hasOwnProperty('inputWidget')) {\n                widget.inputWidget.element.addEventListener('change', event => {\n                    \n                    if (event.target.value != Widget.instanceList[event.target.id].defaultOptions.value) {\n                        this.SaveButton.show()\n                    }\n\n                })\n            }\n        })\n    }\n\n\n    /**\n     * takes the user's input from the task editing widgets and push it\n     * on the server via cacheService.edit Task() method. If server succeed,\n     * updates appearance ot the application appropriately\n     */\n    saveInputValues() {\n        let newTaskFields = this.takeInputValues()\n        newTaskFields.id = this.taskObj.id\n\n        this.cacheService.editTask(newTaskFields)\n            .then(() => {\n                calendar.updDayButtonsStatus()\n                taskPanel.TaskList.update()\n            })\n            .catch(err => {\n                console.error(err)\n            })\n    }\n    /**\n     * sends user input from checkDone checkbox (which indicates whether\n     * a task marked as completed or not) to the server. If server\n     * responds with succeed, the appearance of the application will\n     * appropriately updated\n     */\n    checkUncheckCompletion() {\n        let checkObject = {\n            id: this.taskObj.id,\n            date: this.taskObj.date,\n        }\n\n        if (this.checkDone.element.checked) {\n            checkObject.completion = this.taskObj.date\n        } else {\n            checkObject.completion = false\n        }\n        this.cacheService.checkUncheckTask(checkObject)\n            .then(() => {\n                this.relatedDayButton.updStatus()\n            })\n        //TODO: error catching\n\n    }\n\n    get relatedDayButton() {\n        return this.parent.relatedDayButton\n    }\n\n    get _emptyTaskObj() {\n        console.log(this.parent)\n        return TaskObject.getEmpty({\n            date: this.parent.date,\n            init_date: this.parent.date,\n        })\n    }\n\n}\n\n\nclass TaskAdder extends TaskItem {\n    constructor(parent) {\n        super(parent)\n        this.id = this.makeId('ta')\n    }\n\n    build() {\n        super.build()\n        this.switchToEditMode()\n        this.reBind()\n        this.element.style.order = '-1'\n    }\n\n    reBind() {\n        this.CloseEditorButton.element.onclick = this.remove.bind(this)\n        this.SaveButton.element.onclick = this.createNewTask.bind(this)\n    }\n\n    createNewTask() {\n        let newTask = this.takeInputValues()\n        newTask.id = this.taskObj.id\n\n        let thereIsInterval\n        if (newTask.interval && newTask.interval != 'no') {\n            thereIsInterval = true\n        } else {\n            thereIsInterval = false\n        }\n\n        this.cacheService.createTask(newTask)\n            .then(() => {\n                this.remove()\n                calendar.updDayButtonsStatus()\n                taskPanel.TaskList.update()\n                if (thereIsInterval) {\n                    calendar.refreshMonth()\n                }\n            })\n            .catch(err => {\n                console.error('catched in the end point:', err)\n            })\n    }\n}\n\n\nclass TaskSettingsElement extends Widget {\n    constructor(parent, inputType, taskObj, labelText) {\n        super(parent)\n        this.parent = parent\n        this.element.className = 'tp-SettingsElement'\n        this.taskObj = taskObj\n\n        this.inputWidget = this.initInputWg(inputType)\n        this.label = new Widget(this, { tagName: 'label', innerText: labelText })\n    }\n\n    build() {\n        super.build()\n        this.label.build()\n        this.inputWidget.build()\n    }\n\n    get value() {\n        return this.inputWidget.value\n    }\n\n    set value(defaultValue) {\n        this.inputWidget.value = defaultValue\n    }\n\n    initInputWg(type) {\n        if (type === 'date') {\n            return new Widget(this, {\n                tagName: 'input',\n                type: 'date',\n                name: 'new_date',\n                value: this.taskObj.init_date.toISOString().slice(0, 10)\n            })\n        } else if (type === 'interval') {\n            const inputWg = new Select(this, [\n                ['no', 'no interval'],\n                ['every_day', 'every day'],\n                ['every_workday', 'every workday'],\n                ['every_week', 'every week'],\n                ['every_month', 'every month'],\n                ['every_year', 'every year']\n            ])\n            inputWg.defaultValue = this.taskObj.interval\n            return inputWg\n        } else if (type === 'autoshift') {\n            const inputWg = new Select(this, [\n                [false, 'no'],\n                [true, 'until completed']\n            ])\n            inputWg.defaultValue = this.taskObj.autoshift\n            return inputWg\n        } else if (type === 'input') {\n            const inputWg = new Widget(this, {\n                tagName: 'input',\n                type: 'text',\n                name: 'new_title',\n                maxlength: \"80\",\n                minlength: \"1\",\n                value: this.taskObj.title\n            })\n            return inputWg\n        } else if (type === 'textarea') {\n            return new Widget(this, {\n                tagName: 'textarea',\n                name: 'newDescription',\n                rows: '5',\n                cols: '3',\n                value: this.taskObj.description\n            })\n        }\n    }\n\n    get value() {\n        return this.inputWidget.element.value\n    }\n\n    set value(newValue) {\n        this.inputWidget.element.value = newValue\n    }\n\n    get cacheService() {\n        return this.parent.cacheService\n    }\n\n}\n\n\nmodule.exports = { TaskPanel }\n\n\n//# sourceURL=webpack:///./widgets/widget.taskpanel.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;